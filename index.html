<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Location History Visualizer v19</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
     
    <script src="https://unpkg.com/leaflet-polyline-decorator@1.6.0/dist/leaflet.polylineDecorator.js"></script>

    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; display: flex; flex-direction: column; height: 100vh; }
        
        /* Control Bar */
        #controls {
            background: #ffffff;
            padding: 12px 20px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            gap: 20px;
            align-items: flex-end; 
            justify-content: center;
            flex-wrap: wrap;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05);
            z-index: 1000;
            position: relative;
        }

        .control-group { display: flex; flex-direction: column; gap: 4px; align-items: center; }
        
        /* Standard Labels */
        .control-group > label:not(.custom-file-upload) { 
            font-size: 11px; 
            font-weight: 700; 
            color: #555; 
            text-transform: uppercase; 
            letter-spacing: 0.5px; 
        }
        
        select, input[type="date"] {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 14px;
            background: #fff;
            color: #333;
            min-width: 120px;
        }

        /* Specific width for Type Filter */
        #typeFilter {
            min-width: 180px;
            max-width: 250px;
            text-overflow: ellipsis;
        }

        /* Custom File Input Styling */
        input[type="file"] { display: none; }
        
        .custom-file-upload {
            display: inline-block;
            padding: 8px 24px;
            cursor: pointer;
            background-color: #2563eb;
            color: #ffffff !important;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.2s;
            text-align: center;
            border: 1px solid #2563eb;
            text-transform: none; 
            letter-spacing: normal;
            box-shadow: 0 2px 4px rgba(37, 99, 235, 0.2);
        }
        
        .custom-file-upload:hover { background-color: #1d4ed8; border-color: #1d4ed8; }
        
        /* Action Button */
        #applyBtn {
            padding: 8px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            background-color: #16a34a;
            color: white;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(22, 163, 74, 0.2);
        }
        #applyBtn:hover { background-color: #15803d; }

        /* Legend */
        .legend-bar { background:#f9fafb; padding:8px 20px; display:flex; border-bottom:1px solid #ccc; gap: 20px; flex-wrap: wrap; font-size: 13px; justify-content: center; }
        .legend-item { display: flex; align-items: center; gap: 8px; color: #374151; }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
        .line { width: 24px; height: 3px; display: inline-block; }
        
        /* Map Area */
        #map { flex-grow: 1; width: 100%; background: #e5e5e5; z-index: 1; }
        
        /* Status Bar Overlay */
        #status-bar {
            position: absolute;
            top: 80px;
            right: 10px;
            z-index: 1001;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            color: #444;
            border: 1px solid #ccc;
            pointer-events: none;
        }
        #error-msg { color: #dc2626; font-weight: bold; display: none; margin-left: 10px; }
    </style>
</head>
<body>

    <div id="controls">
        <div class="control-group">
            <label for="fileInput" class="custom-file-upload">
                Upload Data
            </label>
            <input type="file" id="fileInput" accept=".json,.txt">
        </div>

        <div class="control-group">
            <label>Date Range (UTC)</label>
            <div style="display:flex; gap:5px;">
                <input type="date" id="startDate">
                <input type="date" id="endDate">
            </div>
        </div>

        <div class="control-group">
            <label>Data Category</label>
            <select id="catFilter">
                <option value="all">Show All Data</option>
                <option value="visit">Visits</option>
                <option value="timelinePath">Timeline Paths</option>
                <option value="activity">Activities</option>
            </select>
        </div>

        <div class="control-group">
            <label>Detailed Types</label>
            <select id="typeFilter">
                <option value="all">Select a Category</option>
            </select>
        </div>

        <div class="control-group">
            <label>&nbsp;</label>
            <button id="applyBtn">Apply Filters</button>
        </div>
    </div>

    <div class="legend-bar">
        <div class="legend-item"><span class="dot" style="background:#2563eb;"></span> Visit</div>
        <div class="legend-item"><span class="line" style="background:#16a34a;"></span> Timeline Path</div>
        <div class="legend-item"><span class="line" style="background:#f97316; border-bottom: 2px dashed #f97316; height:0;"></span> Activity (A to B)</div>
    </div>

    <div id="status-bar">
        <span id="status">Ready to load file.</span>
        <span id="error-msg"></span>
    </div>

    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
     
    <script src="https://unpkg.com/leaflet-polyline-decorator@1.6.0/dist/leaflet.polylineDecorator.js"></script>

    <script>
        // Initialize Map with MinZoom constraint to prevent excessive zoom-out
        // and MaxBounds to prevent panning off the world
        const map = L.map('map', {
            center: [39.8, -98.5],
            zoom: 4,
            minZoom: 2,
            maxBounds: [[-90, -180], [90, 180]], // Prevent panning past edges
            maxBoundsViscosity: 1.0 // Solid bounce back
        });
        
        let currentFileName = "";
        
        const basemaps = {
            "Carto Voyager": L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', { attribution: '&copy; CARTO', subdomains: 'abcd', maxZoom: 20 }),
            "Carto Voyager (No Labels)": L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png', { attribution: '&copy; CARTO', subdomains: 'abcd', maxZoom: 20 }),
            "Satellite": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles &copy; Esri' }),
            "Satellite Streets": L.layerGroup([
                L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'),
                L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}')
            ]),
            "OpenStreetMap": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap' }),
            "Carto Positron": L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; CARTO', subdomains: 'abcd', maxZoom: 20 }),
            "Carto Dark Matter": L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; CARTO', subdomains: 'abcd', maxZoom: 20 })
        };

        let currentLayer = basemaps["Carto Voyager"];
        currentLayer.addTo(map);
        L.control.layers(basemaps).addTo(map);

        let allMapItems = [];
        const dataLayers = L.layerGroup().addTo(map);

        // --- Helper Functions ---
        function parseGeo(geoStr) {
            if (!geoStr || !geoStr.startsWith('geo:')) return null;
            const parts = geoStr.substring(4).split(',');
            if (parts.length >= 2) return [parseFloat(parts[0]), parseFloat(parts[1])];
            return null;
        }

        function formatUTC(dateObj) {
            if (!dateObj) return "";
            return dateObj.toISOString().replace('T', ' ').substring(0, 19) + ' UTC';
        }

        // --- Data Processor ---
        function processData(rawData) {
            const items = [];
            if (!Array.isArray(rawData)) return items;

            rawData.forEach(entry => {
                const start = entry.startTime ? new Date(entry.startTime) : null;
                const end = entry.endTime ? new Date(entry.endTime) : null;
                if (!start) return;

                // 1. Visit
                if (entry.visit) {
                    const loc = parseGeo(entry.visit.topCandidate.placeLocation);
                    const type = entry.visit.topCandidate.semanticType || "Unknown Visit";
                    if (loc) {
                        items.push({
                            category: 'visit',
                            subType: type,
                            coords: loc,
                            startTime: start,
                            endTime: end
                        });
                    }
                }

                // 2. Timeline Path
                if (entry.timelinePath && Array.isArray(entry.timelinePath) && entry.timelinePath.length > 0) {
                    const points = entry.timelinePath.map(p => {
                        const c = parseGeo(p.point);
                        return c ? { lat: c[0], lng: c[1], offset: p.durationMinutesOffsetFromStartTime } : null;
                    }).filter(p => p !== null);

                    if (points.length > 1) {
                        items.push({
                            category: 'timelinePath',
                            subType: 'GPS Trace',
                            points: points,
                            startTime: start,
                            endTime: end
                        });
                    }
                }

                // 3. Activity
                if (entry.activity) {
                    const s = parseGeo(entry.activity.start);
                    const e = parseGeo(entry.activity.end);
                    const type = entry.activity.topCandidate && entry.activity.topCandidate.type 
                                 ? entry.activity.topCandidate.type 
                                 : "Unknown Activity";

                    if (s && e) {
                        items.push({
                            category: 'activity',
                            subType: type,
                            coords: [s, e],
                            startPoint: s,
                            endPoint: e,
                            startTime: start,
                            endTime: end,
                            distance: entry.activity.distanceMeters
                        });
                    }
                }
            });
            return items;
        }

        // --- Render Logic ---
        function render(items) {
            dataLayers.clearLayers();
            const bounds = L.latLngBounds();
            let count = 0;

            items.forEach(item => {
                // --- A. VISIT ---
                if (item.category === 'visit') {
                    const m = L.circleMarker(item.coords, {
                        radius: 7, fillColor: '#2563eb', color: '#fff', weight: 2, fillOpacity: 0.9
                    });
                    m.bindPopup(`<b>${item.subType}</b><br>Start: ${formatUTC(item.startTime)}<br>End: ${formatUTC(item.endTime)}`);
                    dataLayers.addLayer(m);
                    bounds.extend(item.coords);
                    count++;
                }
                
                // --- B. TIMELINE PATH ---
                else if (item.category === 'timelinePath') {
                    const latlngs = item.points.map(p => [p.lat, p.lng]);
                    
                    const line = L.polyline(latlngs, { color: '#16a34a', weight: 4, opacity: 0.7 });
                    line.bindPopup(`<b>Timeline Path</b><br>Start: ${formatUTC(item.startTime)}<br>End: ${formatUTC(item.endTime)}<br>Points: ${item.points.length}`);
                    dataLayers.addLayer(line);
                    
                    // Render Points
                    item.points.forEach((pt, index) => {
                        const c = L.circleMarker([pt.lat, pt.lng], { radius: 3, fillColor: '#16a34a', color: '#fff', weight: 1, fillOpacity: 1 });
                        
                        const offsetText = pt.offset ? `+ ${pt.offset} min` : "Start (+ 0 min)";
                        const seqText = `Point ${index + 1}/${item.points.length}`;
                        
                        // Extended Popup Content
                        const popupContent = `
                            <b>Timeline Point</b><br>
                            ${seqText}<br>
                            Offset From Start Time: ${offsetText}<br>
                            <hr style="margin: 5px 0; border: 0; border-top: 1px solid #ccc;">
                            Path Start: ${formatUTC(item.startTime)}<br>
                            Path End: ${formatUTC(item.endTime)}
                        `;
                        
                        c.bindPopup(popupContent);
                        dataLayers.addLayer(c);
                        bounds.extend([pt.lat, pt.lng]);
                    });
                    count++;
                }
                
                // --- C. ACTIVITY ---
                else if (item.category === 'activity') {
                    const line = L.polyline(item.coords, { color: '#f97316', weight: 3, opacity: 0.8, dashArray: '5, 10' });
                    const distDisplay = item.distance ? `${Math.round(item.distance)} m` : "N/A";
                    line.bindPopup(`<b>Activity: ${item.subType}</b><br>Distance: ${distDisplay}<br>Start: ${formatUTC(item.startTime)}<br>End: ${formatUTC(item.endTime)}`);
                    dataLayers.addLayer(line);
                    
                    try {
                        const decorator = L.polylineDecorator(line, {
                            patterns: [{ offset: '10%', repeat: '40%', symbol: L.Symbol.arrowHead({ pixelSize: 10, polygon: false, pathOptions: { stroke: true, color: '#f97316' } }) }]
                        });
                        dataLayers.addLayer(decorator);
                    } catch(e) {}

                    const sM = L.circleMarker(item.startPoint, { radius: 4, fillColor: '#fff', color: '#f97316', weight: 2, fillOpacity: 1 });
                    sM.bindPopup(`<b>${item.subType}</b><br>Start Point<br>${formatUTC(item.startTime)}`);
                    dataLayers.addLayer(sM);

                    const eM = L.circleMarker(item.endPoint, { radius: 4, fillColor: '#f97316', color: '#fff', weight: 1, fillOpacity: 1 });
                    eM.bindPopup(`<b>${item.subType}</b><br>End Point`);
                    dataLayers.addLayer(eM);

                    item.coords.forEach(pt => bounds.extend(pt));
                    count++;
                }
            });

            if (count > 0) {
                map.fitBounds(bounds, { padding: [50, 50], maxZoom: 16 });
            }
            
            let statusText = `Displayed ${count} items`;
            if (currentFileName) {
                statusText += ` from <b>${currentFileName}</b>`;
            }
            document.getElementById('status').innerHTML = statusText;
        }

        // --- Filters ---
        function updateTypeDropdown() {
            const cat = document.getElementById('catFilter').value;
            const sel = document.getElementById('typeFilter');
            const types = new Set();

            sel.innerHTML = '';

            // CASE 1: Show All Data -> "Select a Category"
            if (cat === 'all') {
                const opt = document.createElement('option');
                opt.value = 'all';
                opt.innerText = 'Select a Category';
                sel.appendChild(opt);
                return;
            }

            // CASE 2: Specific Category -> "All Types" + Specific Options
            const allOpt = document.createElement('option');
            allOpt.value = 'all';
            allOpt.innerText = 'All Types';
            sel.appendChild(allOpt);

            allMapItems.forEach(item => {
                if (item.category === 'timelinePath') return;
                if (item.category === cat) {
                    types.add(item.subType);
                }
            });

            Array.from(types).sort().forEach(t => {
                const opt = document.createElement('option');
                opt.value = t; opt.innerText = t;
                sel.appendChild(opt);
            });
        }

        function applyFilters() {
            const startStr = document.getElementById('startDate').value;
            const endStr = document.getElementById('endDate').value;
            const cat = document.getElementById('catFilter').value;
            const type = document.getElementById('typeFilter').value;
            
            // Get Status/Error Elements
            const errorBox = document.getElementById('error-msg');
            const statusBox = document.getElementById('status');

            // Reset Error
            errorBox.style.display = 'none';
            statusBox.style.display = 'inline';

            const sDate = startStr ? new Date(startStr + "T00:00:00Z") : new Date(0);
            let eDate;
            if (endStr) {
                eDate = new Date(endStr + "T23:59:59Z");
            } else {
                eDate = new Date(8640000000000000);
            }

            // --- DATE VALIDATION CHECK ---
            if (sDate > eDate) {
                errorBox.innerText = "Error: End Date cannot be earlier than Start Date.";
                errorBox.style.display = 'inline';
                return; // Stop execution
            }

            const filtered = allMapItems.filter(item => {
                if (item.startTime < sDate || item.startTime > eDate) return false;
                if (cat !== 'all' && item.category !== cat) return false;
                if (type !== 'all' && item.subType !== type) return false;
                return true;
            });
            render(filtered);
        }

        // --- Listeners ---
        // Only update dropdown options on category change, do NOT render map
        document.getElementById('catFilter').addEventListener('change', () => {
            updateTypeDropdown();
        });

        document.getElementById('applyBtn').addEventListener('click', applyFilters);

        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            currentFileName = file.name;
            
            document.getElementById('status').innerText = "Processing...";
            document.getElementById('error-msg').style.display = 'none';

            const reader = new FileReader();
            reader.onload = (evt) => {
                let text = evt.target.result;
                
                if (text.includes("type: uploaded file")) {
                    const firstBracket = text.indexOf('[');
                    if (firstBracket > -1) {
                        const lastBracket = text.lastIndexOf(']');
                        if (lastBracket > firstBracket) {
                            text = text.substring(firstBracket, lastBracket + 1);
                        }
                    }
                }

                try {
                    const json = JSON.parse(text);
                    let dataArray = [];
                    if (Array.isArray(json)) dataArray = json;
                    else if (json.fullContent) dataArray = json.fullContent;
                    else if (json.timelineObjects) dataArray = json.timelineObjects; 
                    else if (json.locations) dataArray = json.locations;

                    allMapItems = processData(dataArray);

                    if (allMapItems.length === 0) {
                        document.getElementById('error-msg').innerText = "No valid data found.";
                        document.getElementById('error-msg').style.display = 'inline';
                    } else {
                        const sorted = [...allMapItems].sort((a,b) => a.startTime - b.startTime);
                        document.getElementById('startDate').value = sorted[0].startTime.toISOString().split('T')[0];
                        document.getElementById('endDate').value = sorted[sorted.length-1].startTime.toISOString().split('T')[0];
                        
                        updateTypeDropdown();
                        applyFilters();
                    }
                } catch (err) {
                    console.error(err);
                    document.getElementById('error-msg').innerText = "Error: Invalid JSON.";
                    document.getElementById('error-msg').style.display = 'inline';
                    document.getElementById('status').innerText = "Failed.";
                }
            };
            reader.readAsText(file);
        });
    </script>
</body>
</html>